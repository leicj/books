1. 一般想法
	理想的散列表数据结构只不过是一个包含有关键字的具有固定大小的数组.但将每一个关键字映射到数组中需要散列函数来完成.理想情况下它应该运算简单并且应该保证任何两个不同的关键字映射到不同的单元.只是这是不可能的,因为单元的数目是有限的,而关键字实际上是无限的.所以我们要寻找合理的散列函数在单元之间均匀的分配关键字.

2. 散列函数
	假设关键字为整数,则理想的情况是保证表的大小是素数.但一般情况下关键字都是字符串,我们可以考虑以下散列函数:
1) 将字符串的字符ASCII码相加起来.
unsigned int Hash(const char *key, int tableSize)
{
	unsigned int hashVal = 0;
	while (*key != '\0') {
		hashVal += *key++;
	}

	return hashVal % tableSize;
}
但是这种表无法很好的分配关键字.假设字符串最多为8字节长,而char的最大值为127,则散列值最大为127 * 8 = 1016.如果表的大小很大,则存在浪费空间,并且不好解决冲突问题(即两个字符串的哈希值相同)
2) 将前三个字符进行哈希运算.
unsigned int Hash(const char *key, int tableSize)
{
	return (key[0] + 27 * key[1] + 27 * 27 * key[2]) % tableSize;
}
这种方法理论上解决了分配不均匀情况下,但实际情况是前三个字符一般并不随机,所以理论完美但是实际的字符串不符合要求.
3) 将所有的字符进行哈希运算
unsigned int Hash(const char *key, int tableSize)
{
	unsigned int hashVal = 0;

	while (*key != '\0') {
		hashVal = (HashVal << 5) + *key++;
	}
	return hashVal % tableSize;
}
	但这三种方法都会产生冲突.如果当一个元素被插入时另一个元素已经存在(散列值相同),那么就产生冲突,这种冲突需要消除.通常有两种最简单的消除冲突的方法: 分离链接法和开发定址法.

3. 分离链接法
	将散列到同一个值的所有元素保留到一个表中.如下图所示(假设哈希表的大小为10):
数组索引		值
0-----------0
1-----------1-->81
2-----------
3-----------
4-----------4-->64
5-----------25
6-----------16-->36
7-----------
8-----------
9-----------9-->49
具体实现参考hashlink.c

4. 开放定址法
	在开放定址散列系统中,如果有冲突产生,那么就要尝试选择另外的单元,直到找出空的单元为止.更一般的,单元h0(x),h1(x),h2(x)相继被选中,其中hi(x) = (hash(x) + f(i)) % tableSize, 且f(0) = 0,函数f是冲突解决方法.
	因为所有的数据都要置入表内,所以开放定址法所需要的表要比分离链表散列用表大.
	一般我们有三个解决冲突的方法: 线性探测法, 平方探测法和双散列.
1) 线性探测法
	假设散列表的大小为10, 我们插入{89, 18, 49, 58, 69}. 插入顺序如下:
索引 	值
9		89
8 		18
0 		49(因为和89产生冲突,则放入下一个空闲地址,即0)
1 		58(因为和18产生冲突,则放入下一个空闲地址,即1)
2 		69(因为和89产生冲突,则放入下一个空闲地址,即2)
	这种方法会带来一个很大的问题是: 占据的单元会形成一些区域,结果称为一次聚集.
2) 平方探测法
平方探测是消除线性探测中一次聚集问题的冲突解决方法.平方探测就是冲突函数为二次函数的探测方法,流行的选择时f(i) = i * i.








