1. 等价关系
	若对于每一对元素(a,b), a,b属于S,aRb或者为true或者为false,则称在集合S上定义关系R.如果aRb是true,那么我们说a与b有关系.
等价关系是满足下列三个性质的关系R:
1) 自反性:对于所有的a属于S, aRa
2) 对称性:aRb当且仅当bRa
3) 传递性:若aRb且bRc则aRc
	例如关系"<="不是等价关系,违反对称性.

2. 动态等价性问题
	给定一个等价关系"~",一个自然的问题时对任意的a和b,确定是否a~b.
	我们可以将所有和a存在等价关系的,放在一个区域内.那么对于一个集合来说,由于等价性的分割,会形成多个区域的集合.
	我们可以使用union来将a,b等价起来,通过find来判断两个元素是否存在等价关系.

3. 基本数据结构
假设我们有8个元素:
1 2 3 4 5 6 7 8
执行union(5, 6), union(7, 8), union(5, 7)后,形成如下结构:
1 2 3 4 5   7 8
 		 \
 		  6
1 2 3 4 5   7
  		 \   \
  		  6   8
1 2 3 4 5--7--8
         \
          6

具体实现参考disset.c

4. 灵巧求并算法
	对上诉算法进行简单的合并,使得总让较小的树成为较大的树的子树,这种方法叫做大小合并.
按照大小合并:(union(5, 6), union(7, 8), union(5, 7), union(4, 5))
1 2 3   4---5---7---8
  			 \
  			  6
由于我们只使用一个数组,因此可以让每个根的数组元素包含它的树的大小的负值.这样一来,初始时树的数组表示就都是-1.当执行一次union时,要检查树的大小;新的大小是老得大小的和.
形成的数组为:
-1 -1 -1 5 -5 5 5 7
1  2  3  4 5  6 7 8

另一种实现方法为按高度求并,它同样保证了所有的树的深度最多是O(logN).我们跟踪每棵树的高度而不是大小并执行那些union使得浅的树成为深得树的子树.
void setunion(int *arr, int root1, int root2)
{
	if (arr[root2] < arr[root1]) {
		arr[root1] = root2;
	} else {
		if (arr[root1] == arr[root2]) {
			arr[root1]--;
		}
		arr[root2] = root1;
	}
}
形成的数组为:
0 0 0 5 -2 5 5 7
1 2 3 4 5  6 7 8

5. 路径压缩
	如果要优化数据结构,让O(M log N)的最坏情况尽量不出现,则我们需要路径压缩.
	路径压缩在一次find操作期间执行而与用来执行union的方法无关.设操作为find(x), 此时路径压缩的效果是,从x到根的路径上的每一个节点都使得它的父节点变成根.
算法优化如下:
int find(int x, int *arr)
{
	if (arr[x] <= 0) {
		return x;
	} else {
		return arr[x] = find(arr[x], arr);
	}
}
	路径压缩与按大小求并完全兼容,这就使得两个例程可以同时实现.但路径压缩不完全与按高度求并兼容.
	




















































