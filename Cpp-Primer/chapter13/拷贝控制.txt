	当定义一个类时，我们显式或隐式的指定在此类型的对象拷贝，移动，赋值和销毁时做什么。一个类通过定义五种特殊的成员函数来控制这些操作，包括：拷贝构造函数，拷贝赋值运算符，移动构造函数，移动赋值运算符和析构函数。拷贝和移动构造函数定义了当用同类型的另一个对象初始化本对象时做什么。拷贝和移动赋值运算符定义了一个对象赋予同类型的另一个对象时做什么。析构函数定义了当此类对象销毁时做什么。
	如果一个类没有定义所有这些拷贝控制成员，编译器会自动默认为它定义缺失的操作。但是一般情况下，拷贝控制操作都是必要部分，因为编译器定义的版本的行为可能并非我们所想的。

13.1 拷贝，赋值与销毁
13.1.1 拷贝构造函数
	如果一个构造函数的第一个参数是自身类类型的引用，且任何额外参数都有默认值，则此构造函数是拷贝构造函数。
class Foo{
public:
	Foo();	//默认构造函数
	Foo(const Foo&);	//拷贝构造函数
	// ...
};
合成拷贝构造函数
	如果我们没定义拷贝构造函数，则编译器会默认合成拷贝构造函数。每个成员类型决定了它如何拷贝：对类类型的成员，会使用其拷贝构造函数来拷贝。内置类型的成员则直接拷贝。作为一个例子，我们的Sales_data的合成拷贝构造函数等价于：
class Sales_data{
public:
	Sales_data(const Sales_data&);
private:
	std::string bookNo;
	int units_sold = 0;
	double revenue = 0.0;
};

Sales_data::Sales_data(const Sales_data &orig):
	bookNo(orig.bookNo),
	units_sol(orig.units_sold),
	revenue(orig.revenue)
{}
拷贝初始化
string dots(10, '.');				//直接初始化
string s(dots);						//直接初始化
string s2 = dots;					//拷贝初始化
string null_book = "9-99-9999-9";	//拷贝初始化
string ninues = string(100, '9');	//拷贝初始化
	直接初始化时，实际上是编译器调用合适的构造函数来初始化。当我们使用拷贝初始化时，我们要求编译器将右侧运算对象拷贝到正在创建的对象中。如果需要的话还需进行类型转换。
	拷贝初始化不仅在我们用=定义变量时会发生，下列三种情况也会发生：
1） 将一个对象作为实参传递给一个非引用类型的形参。
2） 从一个返回类型为非引用类型的函数返回一个对象
3） 用花括号列表初始化一个数组中的元素或一个聚合类中的成员。
参数与返回值
	拷贝构造函数被用来初始化非引用类类型参数，这一特性解释了为什么拷贝构造函数子集的参数必须是引用类型。如果其参数不是引用类型，则调用永远也不会成功--为了调用拷贝构造函数，我们必须先拷贝它的实参，为了拷贝它的实参，我们又需要调用拷贝构造函数，如此无限循环。
拷贝初始化的限制
	如果我们使用的初始化值要求通过一个explicit的构造函数来进行类型转换，那么使用拷贝初始化还是直接初始化就不是无关紧要的。

13.1.2 拷贝赋值运算符
	与类控制其对象如何初始化一样，类也可以控制其对象如何赋值（未定义情况下，编译器会默认合并一个）：
Sales_data trans, accum;
trans = accum;
	拷贝赋值运算符接受一个与其所在类相同类型的参数：
class Foo{
public:
	Foo &operator=(const Foo&);
};
	为了与内置类型的赋值保持一致，赋值运算符通常返回一个指向其左侧运算对象的引用。
作为一个例子，下面的代码等价于Sales_data的合成拷贝赋值运算符：
Sales_data& Sales_data::operator=(const Sales_data &rhs)
{
	bookNo = rhs.bookNo;
	units_sold = rhs.units_sold;
	revenue = rhs.revenue;
	return *this;
}

13.1.3 析构函数
	析构函数执行与构造函数相反的操作：构造函数初始化对象的非static数据成员；析构函数释放对象使用的资源，并销毁对象的非static数据成员。
	析构函数是类的一个成员函数，名字由波浪号+类名构成。它没有返回值，也不接受参数(所以不能重载)：
class Foo{
public:
	~Foo();
};
析构函数完成什么工作
	在一个构造函数中，成员的初始化是在函数体执行之前完成的，且按照它们在类中出现的顺序进行初始化。在一个析构函数中，首先执行函数体，然后销毁成员。成员按初始化顺序的逆序销毁。
什么时候会调用析构函数
	无论何时一个对象被销毁，就会自动调用其析构函数。
合成析构函数
	当一个类未定义子集的析构函数时，编译器会为它定义一个合成析构函数。
class Sales_data{
public:
	~Sales_data(){}
};
	在合成析构函数中，函数体自身并不直接销毁成员。成员是在析构函数体之后隐含的析构阶段中被销毁的。在整个对象销毁过程中，析构函数体是作为成员销毁步骤之外的另一部分而进行的。

13.1.4 三/五法则
需要析构函数的类也需要拷贝和赋值操作。
	当我们决定一个类是否要定义它子集版本的拷贝控制成员时，一个基本原则是首先确定这个类是否需要一个析构函数。如果这个类需要一个析构函数，我们几乎可以肯定它也需要一个拷贝构造函数和一个赋值运算符。
	考虑这种情况，对象存在一个指针变量，在构建时候动态分配内存，在析构函数中进行内存的释放。但如果在拷贝时候，将地址拷贝过去，则析构时候会出现A,B两个对象，A将指针空间释放，但是B再次析构时候，会释放已经释放的空间，出现错误。
需要拷贝操作的类也需要赋值操作，反之亦然
	
13.1.5 使用=default
	我们可以通过将拷贝控制成员定义为=default来显式的要求编译器生成合成的版本：
class Sales_data {
public:
	Sales_data() = default;
	Sales_data(const Sales_data&) = default;
	Sales_data& operator=(const Sales_data&);
	~Sales_data() = default;	
};
Sales_data& Sales_data::operator=(const Sales_data&) = default;//非内联函数

13.1.6 阻止拷贝
	大多数类应该定义默认构造函数，拷贝构造函数和拷贝赋值运算符，无论是隐式的还是显式的。
	对于某些类来说，必须采用某种机制阻止拷贝或赋值。例如，iostream类阻止了拷贝，以避免多个对象写入或读取相同的IO缓冲。
定义删除函数
	在新标准下，我们可以通过将拷贝构造函数和拷贝赋值运算符定义为删除的函数来阻止拷贝。删除的函数是这样一种函数：我们虽然声明了它们，但不能以任何方式使用它们。在函数的参数列表后面加上=delete来指出我们希望将它定义为删除：
class NoCopy{
public:
	NoCopy() = default;
	NoCopy(const NoCopy&) = delete;
	NoCopy &operator=(const NoCopy&) = delete;
	~NoCopy() = default;
};
1) 与default不同，=delete必须出现在函数第一次声明的时候，因为编译器需要知道一个函数是删除的，以便禁止试图使用它操作。
2) 我们可以对任何函数使用delete。
析构函数不能是删除的成员
	我们不能删除析构函数。如果析构函数被删除，就无法销毁此类型的对象了，所以我们不能定义该类的变量或临时对象。
class NoDtor{
public:
	NoDtor() = default;	//使用合成默认构造函数
	~NoDtor() = delete; //我们不能销毁NoDtor类型的对象
};
NoDtor nd;	//错误：NoDtor的析构函数是删除的
NoDtor *p = new NoDtor(); //正确： 但我们不能delete p
delete p; //错误： NoDtor的析构函数是删除的
合成的拷贝控制成员可能是删除的
	基本规则是： 如果一个类有数据成员不能默认构造，拷贝，复制或销毁，则对应的成员函数将被定义为删除的。
1) 如果类的某个成员的析构函数是删除的或不可访问的(private)，则类的合成析构函数被定义为删除的。
2) 如果类的某个成员的拷贝构造函数是删除的或不可访问的，则类的合成拷贝构造函数被定义为删除的。如果类的某个成员的析构函数是删除的或不可访问的，则类合成的拷贝构造函数也被定义为删除的（如果没有这条规则，我们将会创建出无法销毁的对象）。
3) 如果类的某个成员的拷贝赋值运算符是删除的或不可访问的，或是类有一个const的或引用成员，则类的合成拷贝赋值运算符被定义为删除的。
private拷贝控制
	在新标准发布之前，类是通过将其拷贝构造函数和拷贝赋值运算符声明为private来阻止拷贝：
class PrivateCopy{
public:
	PrivateCopy() = default;
	~PrivateCopy();
private:
	PrivateCopy(const PrivateCopy&);
	PrivateCopy &operator=(const PrivateCopy&);
};
	但是我们不定义拷贝构造函数和拷贝赋值运算符。这样无论哪些函数定义它们，均会出现语法错误。

13.2 拷贝控制和资源管理
	类的行为像一个值，意味着它应该也有子集的状态。当我们拷贝一个像值的对象时，副本和原对象是完全独立的。改变副本不会对原对象有任何影响，反之亦然。
	行为像指针的类则共享状态。当我们拷贝一个这种类的对象时，副本和原对象使用相同的底层数据。改变副本也会改变原对象，反之亦然。
13.2.1 行为像值的类
1) 定义一个拷贝构造函数，完成string的拷贝，而不是拷贝指针
2) 定义一个析构函数来释放string
3) 定义一个拷贝赋值运算符来释放对象当前的string，并从右侧运算对象来拷贝string
class HasPtr{
public:
	HasPtr(const std::string &s = std::string()) :
		ps(new std::string(s)), i(0){}
	HasPtr(const HasPtr &p):
		ps(new string(*p.ps)), i(p.i){}
	HasPtr& operator=(const HasPtr &);
	~HasPtr() {delete ps;}
private:
	std::string *ps;
	int i;
};
HasPtr &HasPtr::operator=(const HasPtr &rhs)
{
	auto newp = new string(*rhs.ps);
	delete ps;
	ps = newp;
	i = rhs.i;
	return *this;
}
赋值运算符中，要考虑自赋值情况。
	当你编写赋值运算符时，有两点需要记住：
1) 如果将一个对象赋予它自身，赋值运算符必须能正确工作。
2) 大多数赋值运算符组合了析构函数和拷贝构造函数的工作。
当你编写一个赋值运算符时，一个好的模式是先将右侧运算对象拷贝到一个局部临时对象中，当拷贝完成后，销毁左侧运算对象的现有成员就是安全的。一旦左侧的运算对象的资源被销毁，就只剩下将数据从临时对象拷贝到左侧运算对象的成员中。
13.2.2 定义行为像指针的类
	对于行为类似指针的类，我们需要为其定义拷贝构造函数和拷贝赋值运算符，来拷贝指针成员本身而不是它指向的string。析构函数不能单方面的释放关联的string。只有当最后一个指向string的HasPtr销毁时，它才可以释放string。
	我们通过引用计数来控制资源的释放。引用计数的工作方式如下：
1) 除了初始化对象外，每个构造函数（拷贝构造函数除外）还要创建一个引用计数，用来记录有多少对象与正在创建的对象共享状态。当我们创建一个对象时，只有一个对象共享状态，因此将计数器初始化为1.
2) 拷贝构造函数不分配新的计数器，而是拷贝给定对象的数据成员，包括计数器。拷贝构造函数递增共享的计数器，指出给定对象的状态又被一个新用户所共享。
3) 析构函数递减计数器，指出共享状态的用户少了一个。如果计数器变为0，则析构函数释放状态。
4) 拷贝赋值运算符递增右侧运算对象的计数器，递减左侧运算对象的计数器。如果左侧运算对象的计数器变为0，意味着它的共享状态没有用户了，拷贝赋值运算符就必须销毁状态。
	计数器保存在动态内存中。当创建一个对象时，我们也分配一个新的计数器。当拷贝或赋值对象时，我们拷贝指向计数器和指针。
具体实现参考13.27.cpp

13.3 交换操作
	swap经常在交换元素上使用。但是标准库的swap在交换指针时候，通常是swap其指针所指向的值，而非指针本身。这样会造成产生无用的副本操作。
	我们可以编写swap函数，用来交换指针而非指针所指向的对象：
class HasPtr{
	friend void swap(HasPtr &, HasPtr &);
};
inline void swap(HasPtr& lhs, HasPtr &rhs)
{
	using std::swap;
	swap(lhs.ps, rhs.ps);
	swap(lhs.i, rhs.i);
}
swap函数应该调用swap，而不是std::swap
	以下两个函数的swap是有区别的：
void swap(Foo &lhs, Foo &rhs)
{
	std::swap(lhs.h, rhs.h);
}
这里调用的是标准库的swap，而非Foo自定义的swap（如果有的话）
void swap(Foo &lhs, Foo &rhs)
{
	using std::swap;
	swap(lhs.h, rhs.h);
}
这里会优先使用Foo自定义的swap，其次才是标准库的swap。
在赋值运算符中使用swap
	以下代码诠释了拷贝并交换的技术：
HasPtr &HasPtr::operator=(HasPtr rhs)
{
	// 交换左侧运算对象和局部变量rhs的内容
	swap(*this, rhs);	//rhs现在指向本对象曾经使用的内存
	return *this;		// rhs被销毁，从而delete了rhs中的指针
}

13.4 拷贝控制示例
	参考message.cpp

13.5 动态内存管理类
	pass。第12章还没看。

13.6 对象移动
13.6.1 右值引用
	所谓右值引用就是必须绑定到右值的引用，通过&&来获取右值引用。返回非引用类型的函数，连同算术，关系，位以及后置递增/递减运算符，都生成右值。
左值持久；右值短暂
	左值具有持久的状态，右值要么是字面常量，要么是在表达式求值过程中创建的临时对象。
	由于右值引用只能绑定到临时对象，我们得知：
1) 所引用的对象将要被销毁
2) 该对象没有其他用户。
	这两个特性意味着：使用右值引用的代码可以自由的接管所引用的对象的资源。
变量是左值
	变量可以看做只有一个运算对象而没有运算符的表达式。
int &&rr1 = 42;	//正确： 字面常量是右值
int &&rr2 = rr1;//错误： 表达式rr1是左值
标准库move函数
	虽然不能将一个右值引用直接绑定到一个左值上，但我们可以显式的将一个左值转换为对应的右值引用类型。
	新标准库函数std::move获得绑定到左值上的右值引用。
int &&rr3 = std::move(rr1);
13.6.2 移动构造函数和移动赋值运算符
	移动构造函数和移动赋值运算符用于从给定“对象”窃取资源而不是拷贝资源。
	移动构造函数的第一个参数必须是右值引用，而且任何额外的参数都必须有默认实参。一旦资源完成移动，源对象必须不再指向被移动的资源---这些资源任何额外所有权已经归属新创建的对象。
StrVec::StrVec(StrVec &&s) noexcept
	: elements(s.elements), first_free(s.first_free), cap(s.cap)
	{
		s.elements = s.first_free = s.cap = nullptr;
	}
1) noexcept: 通知标准库此构造函数不抛出任何异常
2) 移动构造函数不分配任何新内存；它接管给定的StrVec中的内存。在接管内存之后，它将给定对象中的指针都置为nullptr。这样就完成了从给定对象的移动操作，此对象将继续存在。
移动操作，标准库容器和异常
	除非标准库直到我们的移动构造函数不会抛出异常，否则它会认为移动我们的类对象时可能会抛出异常，并且为了处理这种可能性而做一些额外的工作。
	一种通知标准库的方法是在我们的构造函数中指明noexcept，并且在声明和定义中都指定noexcept.
class StrVec{
public:
	StrVec(StrVec &) noexcept; //移动构造函数
};
StrVec::StrVec(StrVec &&s) noexcept : /* 成员初始化 */
{}
	移动操作不抛出异常基于两个事实：首先是抛出异常是允许的。 其次，标准库容器能对异常发生时其自身的行为提供保障。
	例如，在vector的push_back的操作，可能会引发vector的内存的移动分配。这时候如果移动内存时候发生异常，则STL需保证vector回退为原始的值，即push_back操作失效而vector保持不变。基于这种考虑，STL在push_back的操作中执行的是拷贝构造函数而非移动构造函数（即使确定没有异常发生的情况下）。当我们强制声明noexcept时，才能保证STL对vector等操作执行的是移动构造函数。
移动赋值运算符
StrVec &StrVec::operator=(StrVec &&rhs) noexcept
{
	if (this != &rhs) {
		free();
		elements = rhs.elements;
		frist_free = rhs.first_free;
		cap = rhs.cap;
		rhs.elements = rhs.first_free= rhs.cap = nullptr;
	}
	return *this;
}
移后源对象必须可析构
	在移动操作之后，移后源对象必须保持有效的，可析构的状态，但是用户不能对其值进行任何假设。
合成的移动操作
	只有当一个类没有定义任何自己版本的拷贝控制成员，且类的每个非static数据成员都可以移动时，编译器才会为它合成移动构造函数或移动赋值运算符。编译器可以移动内置类型的成员。如果一个成员是类类型，且该类有对应的移动操作，编译器也能移动这个成员。
// 编译器会为X和hashX合成移动操作
struct X {
	int i;	//内置类型可以移动
	std::string s;	//string定义了自己的移动操作
};
struct hasX {
	X mem;	//X有合成的移动操作
};
X x, x2 = std::move(x);			//使用合成的移动构造函数
hasX hx, hx2 = std::move(hx);	//使用合成的移动构造函数
备注： 由于本身的GCC未实现新标准的右值引用，故无法通过编码来论证，无法深入理解。所以后面小部分关于右值引用的，暂时不看。